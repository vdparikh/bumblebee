package store

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/suite"
	"github.com/vdparikh/compliance-automation/backend/models"
	_ "github.com/lib/pq" // PostgreSQL driver
)

// AuditLogStoreTestSuite defines the test suite
type AuditLogStoreTestSuite struct {
	suite.Suite
	Store *DBStore
	db    *sqlx.DB
}

// SetupSuite runs once before all tests in the suite
func (s *AuditLogStoreTestSuite) SetupSuite() {
	dbUser := os.Getenv("TEST_DB_USER")
	if dbUser == "" {
		dbUser = "testuser"
	}
	dbPassword := os.Getenv("TEST_DB_PASSWORD")
	if dbPassword == "" {
		dbPassword = "testpassword"
	}
	dbHost := os.Getenv("TEST_DB_HOST")
	if dbHost == "" {
		dbHost = "localhost"
	}
	dbPort := os.Getenv("TEST_DB_PORT")
	if dbPort == "" {
		dbPort = "5433" // Common port for test DBs to avoid conflict with dev
	}
	dbName := os.Getenv("TEST_DB_NAME")
	if dbName == "" {
		dbName = "test_compliance_db"
	}

	dataSourceName := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		dbUser, dbPassword, dbHost, dbPort, dbName)

	var err error
	s.db, err = sqlx.Connect("postgres", dataSourceName)
	if err != nil {
		log.Fatalf("Could not connect to test database: %v. Make sure the test DB is running and configured.", err)
	}
	s.Store = &DBStore{DB: s.db}

	// Ensure users table exists for foreign key constraints if not managed by migrations for tests
	_, err = s.db.Exec(`
        CREATE TABLE IF NOT EXISTS users (
            id UUID PRIMARY KEY,
            name VARCHAR(255) NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            role VARCHAR(50) NOT NULL,
            hashed_password VARCHAR(255),
            created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
        );
    `)
	if err != nil {
		log.Fatalf("Failed to ensure users table exists: %v", err)
	}
	// Ensure audit_logs table exists (schema from db.sql)
	_, err = s.db.Exec(`
		CREATE TABLE IF NOT EXISTS audit_logs (
			id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
			timestamp TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
			user_id UUID REFERENCES users(id) ON DELETE SET NULL,
			action VARCHAR(255) NOT NULL,
			entity_type VARCHAR(100) NOT NULL,
			entity_id UUID NOT NULL,
			changes JSONB,
			created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
		);
	`)
	if err != nil {
		log.Fatalf("Failed to ensure audit_logs table exists: %v", err)
	}
}

// TearDownSuite runs once after all tests in the suite
func (s *AuditLogStoreTestSuite) TearDownSuite() {
	// s.db.Exec("DROP TABLE IF EXISTS audit_logs;") // Optional: Drop table after tests
	// s.db.Exec("DROP TABLE IF EXISTS users;")      // Optional: Drop users if it was created here
	s.db.Close()
}

// SetupTest runs before each test
func (s *AuditLogStoreTestSuite) SetupTest() {
	// Clean up audit_logs table before each test
	_, err := s.db.Exec("DELETE FROM audit_logs;")
	if err != nil {
		log.Fatalf("Failed to clean audit_logs table: %v", err)
	}
	// Clean up users table if necessary, or ensure specific test users
	_, err = s.db.Exec("DELETE FROM users;")
	if err != nil {
		log.Fatalf("Failed to clean users table: %v", err)
	}
}

func (s *AuditLogStoreTestSuite) createTestUser(id, name, email, role string) *models.User {
	user := &models.User{
		ID:    id,
		Name:  name,
		Email: email,
		Role:  role,
	}
	_, err := s.db.Exec("INSERT INTO users (id, name, email, role) VALUES ($1, $2, $3, $4)",
		user.ID, user.Name, user.Email, user.Role)
	s.Require().NoError(err, "Failed to insert test user")
	return user
}


func (s *AuditLogStoreTestSuite) TestInsertAndGetAuditLog() {
	testUser := s.createTestUser(uuid.NewString(), "Test User One", "test1@example.com", "admin")

	changesMap := map[string]interface{}{"field": "new_value", "old_field": "old_value"}
	changesJSON, _ := json.Marshal(changesMap)

	logEntry := &models.AuditLog{
		// ID is auto-generated by DB
		Timestamp:  time.Now().UTC().Truncate(time.Millisecond), // Truncate for DB precision
		UserID:     &testUser.ID,
		Action:     "test_insert",
		EntityType: "test_entity_type",
		EntityID:   uuid.NewString(),
		Changes:    models.JSONB(changesJSON),
		// CreatedAt is auto-generated
	}

	err := s.Store.InsertAuditLog(logEntry)
	s.Require().NoError(err)
	s.NotEmpty(logEntry.ID, "Inserted log should have an ID from the DB")

	// Retrieve to verify (using a direct query for simplicity, or a GetAuditLogByID if it existed)
	var retrievedLog models.AuditLog
	err = s.db.Get(&retrievedLog, "SELECT * FROM audit_logs WHERE id = $1", logEntry.ID)
	s.Require().NoError(err)

	assert.Equal(s.T(), logEntry.Timestamp.Unix(), retrievedLog.Timestamp.Unix()) // Compare Unix seconds
	assert.Equal(s.T(), *logEntry.UserID, *retrievedLog.UserID)
	assert.Equal(s.T(), logEntry.Action, retrievedLog.Action)
	assert.Equal(s.T(), logEntry.EntityType, retrievedLog.EntityType)
	assert.Equal(s.T(), logEntry.EntityID, retrievedLog.EntityID)

	var expectedChangesMap, actualChangesMap map[string]interface{}
	s.Require().NoError(json.Unmarshal(logEntry.Changes, &expectedChangesMap))
	s.Require().NoError(json.Unmarshal(retrievedLog.Changes, &actualChangesMap))
	assert.Equal(s.T(), expectedChangesMap, actualChangesMap)
}

func (s *AuditLogStoreTestSuite) TestGetAuditLogs_FilteringAndPagination() {
	user1 := s.createTestUser(uuid.NewString(), "User Alpha", "alpha@example.com", "admin")
	user2 := s.createTestUser(uuid.NewString(), "User Beta", "beta@example.com", "auditor")

	entityID1 := uuid.NewString()
	entityID2 := uuid.NewString()

	// Insert sample logs
	log1 := models.AuditLog{Timestamp: time.Now().Add(-5 * time.Hour).UTC(), UserID: &user1.ID, Action: "action_a", EntityType: "type_x", EntityID: entityID1, Changes: models.JSONB(`{"data":"log1"}`)}
	log2 := models.AuditLog{Timestamp: time.Now().Add(-4 * time.Hour).UTC(), UserID: &user2.ID, Action: "action_b", EntityType: "type_y", EntityID: entityID2, Changes: models.JSONB(`{"data":"log2"}`)}
	log3 := models.AuditLog{Timestamp: time.Now().Add(-3 * time.Hour).UTC(), UserID: &user1.ID, Action: "action_c", EntityType: "type_x", EntityID: entityID2, Changes: models.JSONB(`{"data":"log3"}`)}
	log4 := models.AuditLog{Timestamp: time.Now().Add(-2 * time.Hour).UTC(), UserID: nil, Action: "system_action", EntityType: "system", EntityID: uuid.NewString()} // System log

	for _, l := range []*models.AuditLog{&log1, &log2, &log3, &log4} {
		err := s.Store.InsertAuditLog(l)
		s.Require().NoError(err)
	}

	s.T().Run("filter by user_id", func(t *testing.T) {
		filters := map[string]interface{}{"al.user_id": user1.ID}
		logs, total, err := s.Store.GetAuditLogs(filters, 1, 10)
		assert.NoError(t, err)
		assert.Equal(t, 2, total)
		assert.Len(t, logs, 2)
		for _, l := range logs {
			assert.Equal(t, user1.ID, *l.UserID)
			assert.NotNil(t, l.User)
			assert.Equal(t, user1.ID, *l.User.ID)
			assert.Equal(t, user1.Name, *l.User.Name)
		}
	})

	s.T().Run("filter by entity_type", func(t *testing.T) {
		filters := map[string]interface{}{"al.entity_type": "type_y"}
		logs, total, err := s.Store.GetAuditLogs(filters, 1, 10)
		assert.NoError(t, err)
		assert.Equal(t, 1, total)
		assert.Len(t, logs, 1)
		assert.Equal(t, log2.ID, logs[0].ID)
		assert.NotNil(t, logs[0].User)
		assert.Equal(t, user2.ID, *logs[0].User.ID)
	})

	s.T().Run("filter by entity_id", func(t *testing.T) {
		filters := map[string]interface{}{"al.entity_id": entityID2}
		logs, total, err := s.Store.GetAuditLogs(filters, 1, 10)
		assert.NoError(t, err)
		assert.Equal(t, 2, total) // log2 and log3
		assert.Len(t, logs, 2)
	})

	s.T().Run("filter by date range", func(t *testing.T) {
		filters := map[string]interface{}{
			"start_date": time.Now().Add(-3 * time.Hour).Add(-30 * time.Minute).UTC(), // Should include log3
			"end_date":   time.Now().Add(-3 * time.Hour).Add(30 * time.Minute).UTC(),  // Should include log3
		}
		logs, total, err := s.Store.GetAuditLogs(filters, 1, 10)
		assert.NoError(t, err)
		assert.Equal(t, 1, total)
		assert.Len(t, logs, 1)
		assert.Equal(t, log3.ID, logs[0].ID)
	})

	s.T().Run("pagination", func(t *testing.T) {
		logs, total, err := s.Store.GetAuditLogs(map[string]interface{}{}, 1, 2) // Page 1, Limit 2
		assert.NoError(t, err)
		assert.Equal(t, 4, total)
		assert.Len(t, logs, 2)
		// Order is DESC by timestamp, so log4 (system_action) should be first if its timestamp is latest
		// Actually, InsertAuditLog sets Timestamp from the model, so order is log4, log3, log2, log1
		assert.Equal(t, log4.ID, logs[0].ID)
		assert.Nil(t, logs[0].User) // System action has nil user
		assert.Equal(t, log3.ID, logs[1].ID)

		logs, total, err = s.Store.GetAuditLogs(map[string]interface{}{}, 2, 2) // Page 2, Limit 2
		assert.NoError(t, err)
		assert.Equal(t, 4, total)
		assert.Len(t, logs, 2)
		assert.Equal(t, log2.ID, logs[0].ID)
		assert.Equal(t, log1.ID, logs[1].ID)
	})

	s.T().Run("fetch all (limit 0)", func(t *testing.T) {
		logs, total, err := s.Store.GetAuditLogs(map[string]interface{}{}, 1, 0)
		assert.NoError(t, err)
		assert.Equal(t, 4, total)
		assert.Len(t, logs, 4)
	})

	s.T().Run("system log has nil user info", func(t *testing.T) {
		filters := map[string]interface{}{"al.action": "system_action"}
		logs, total, err := s.Store.GetAuditLogs(filters, 1, 10)
		assert.NoError(t, err)
		assert.Equal(t, 1, total)
		assert.Len(t, logs, 1)
		assert.Equal(t, log4.ID, logs[0].ID)
		assert.Nil(t, logs[0].UserID)
		assert.Nil(t, logs[0].User) // User struct should be nil
	})
}


// TestAuditLogStore runs the test suite
func TestAuditLogStore(t *testing.T) {
	// Ensure TEST_DB_PASSWORD is set if you want to run this
	if os.Getenv("TEST_DB_PASSWORD") == "" {
		t.Skip("Skipping integration tests: TEST_DB_PASSWORD not set.")
		return
	}
	suite.Run(t, new(AuditLogStoreTestSuite))
}
